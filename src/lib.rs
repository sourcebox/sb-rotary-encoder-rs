#![doc = include_str!("../README.md")]
#![cfg_attr(not(test), no_std)]
#![warn(missing_docs)]

/// Map containing values for the transitions between input states.
/// - 0: invalid transition
/// - 1: clockwise movement
/// - -1: counter-clockwise movement
#[rustfmt::skip]
const STATE_MAP: [[i8; 4]; 4] = [
    [0, -1, 1, 0],
    [1, 0, 0, -1],
    [-1, 0, 0, 1],
    [0, 1, -1, 0]
];

/// Encoder struct with internal states.
#[derive(Debug, Default)]
pub struct RotaryEncoder {
    /// Last state of input signals, range is 0..3.
    inputstate: u8,

    /// Initial input state, used to resync the switching point.
    initial_inputstate: Option<u8>,

    /// Current raw value independent of the pulse divider.
    raw_value: i32,

    /// Nominal value respecting the pulse divider.
    value: i32,

    /// Tick value of last event.
    tick: Option<u64>,
}

impl RotaryEncoder {
    /// Creates a new instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Updates the processor and returns an event if a movement is detected.
    /// - `input_a` and `input_b` are the signals of the encoder pins.
    /// - `tick` is a monotonic value from the system clock used for velocity calculation.
    /// - `pulse_divider` determines how many pulses must occur before an event is generated.
    pub fn update<T: Into<bool>>(
        &mut self,
        input_a: T,
        input_b: T,
        tick: Option<u64>,
        pulse_divider: i32,
    ) -> Option<RotaryEncoderEvent> {
        let inputstate = ((input_a.into() as u8) << 1) | (input_b.into() as u8);

        if inputstate == self.inputstate {
            // Input state has not changed.
            return None;
        }

        if self.initial_inputstate.is_none() {
            // Store the input stage on first call. This state is regarded as rest position
            // and will be used later to resync the switching point.
            self.initial_inputstate = Some(inputstate);
        }

        let state_value = STATE_MAP[self.inputstate as usize][inputstate as usize];
        self.inputstate = inputstate;

        if state_value == 0 {
            // No valid transition detected.
            return None;
        }

        self.raw_value += state_value as i32;

        if self.raw_value % pulse_divider != 0 {
            // Number of steps not reached yet.
            return None;
        }

        let value = self.raw_value / pulse_divider;

        if pulse_divider > 1 {
            // Realign the raw value to the pulse divider to ensure everything stays in sync.
            let aligned_raw_value =
                ((self.raw_value + (pulse_divider - 1)) / pulse_divider) * pulse_divider;
            if self.raw_value != aligned_raw_value {
                self.raw_value = aligned_raw_value;
                self.value = self.raw_value / pulse_divider;
            }
            self.inputstate = self.initial_inputstate.unwrap_or_default();
        }

        let timedelta = if let Some(timestamp) = tick {
            Some(timestamp - self.tick.unwrap_or_default())
        } else {
            None
        };

        let event = Some(RotaryEncoderEvent {
            value,
            direction: if state_value > 0 {
                Direction::Clockwise
            } else {
                Direction::CounterClockwise
            },
            timedelta,
        });

        self.value = value;
        self.tick = tick;

        event
    }

    /// Resets all internal states to initial values.
    pub fn reset(&mut self) {
        *self = Self::default();
    }

    /// Returns the current value.
    pub fn value(&self) -> i32 {
        self.value
    }

    /// Sets the current value.
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }
}

/// Event generated by the `process()` function.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct RotaryEncoderEvent {
    /// Absolute position value.
    value: i32,

    /// Direction of movement.
    direction: Direction,

    /// Optional time units elapsed since last event.
    timedelta: Option<u64>,
}

impl RotaryEncoderEvent {
    /// Returns the current value.
    pub fn value(&self) -> i32 {
        self.value
    }

    /// Returns the direction of movement.
    pub fn direction(&self) -> Direction {
        self.direction
    }

    /// Returns the step value. +1 for clockwise, -1 for counter-clockwise.
    pub fn step(&self) -> i32 {
        match self.direction {
            Direction::Clockwise => 1,
            Direction::CounterClockwise => -1,
        }
    }

    /// Returns optional time units since last event.
    pub fn timedelta(&self) -> Option<u64> {
        self.timedelta
    }

    /// Returns the optional velocity in respect of the timebase.
    /// E.g. if `process()` is called in 1ms intervall, the timebase is 1000. Calling this
    /// function with that value will return the number of events per second.
    pub fn velocity(&self, update_freq: i32) -> Option<i32> {
        if let Some(timedelta) = self.timedelta {
            if timedelta > 0 {
                Some((update_freq as u64 / timedelta) as i32)
            } else {
                Some(0)
            }
        } else {
            None
        }
    }
}

/// Direction of encoder movement.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Direction {
    /// Clockwise movement.
    Clockwise,

    /// Counter-clockwise movement.
    CounterClockwise,
}

#[cfg(test)]
mod tests;
